# subset
因为两边的和是固定的，所以可以用dp算和为一半时的方案数

f\[i\]\[j\]表示考虑前i个数，和为j的方案数，拿与不拿两种情况加起来。

典型01背包，可以通过调整填表顺序压缩到一维数组。

# preface
模拟硬做就行，注意十进制位上互相独立，以及罗马数字的平移对称性。

# runround
基本上也是模拟硬做，可以加几个优化;
- 满足条件的数字只有457个，可以记录各位数的min max，输入数据大于本位数的max的时候，直接输出大一位的min就行
- 确定位数之后就可以预处理后k位的位置

当然因为只有457个所以全部构造出来再线性查找都能过（

# lamps
经典例题，考虑按钮的顺序不影响结果，次数只有奇数次和偶数次，且123三个操作可以互相转化。~~是群论题~~

考虑c=0,1,2三种情况下的特例，其他的都可以枚举，连dfs都不用。